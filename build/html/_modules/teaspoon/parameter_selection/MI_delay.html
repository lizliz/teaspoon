

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>teaspoon.parameter_selection.MI_delay &mdash; teaspoon 0.1.0 documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: white" >
          

          
            <a href="../../../index.html" class="icon icon-home" alt="Documentation Home"> teaspoon
          

          
            
            <img src="../../../_static/teaspoon.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">1. Getting Started</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../installation.html#requirements">1.1. Requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../installation.html#installation">1.2. Installation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../modules.html">2. Modules</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../parameter_selection.html">2.1. Parameter Selection Module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../MI.html">2.1.1. Mutual Information</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../AC.html">2.1.2. Auto-correlation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../FSA.html">2.1.3. Fourier Spectrum Analysis</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../PAMI.html">2.1.4. Permutation Auto Mutual Information</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../MsPE.html">2.1.5. Multi-scale Permutation Entropy</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../FNN.html">2.1.6. False Nearest Neighbors</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../ML.html">2.2. Machine Learning (ML) Module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../F_PD.html">2.2.1. Featurization</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../CL.html">2.2.2. Classification</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../ML.html#references">2.2.3. References</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../TDA.html">2.3. Topological Data Analaysis (TDA) Module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../PHN.html">2.3.1. Persistent Homology of Networks (PHN) Module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../distances.html">2.3.2. Distances</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../drawing.html">2.3.3. Drawing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../persistence.html">2.3.4. Persistence</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../SP.html">2.4. Signal Processing (SP) Module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../tsa.html">2.4.1. Time Series Analysis (TSA) Tools</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../network.html">2.4.2. Network Representation of Time Series</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../information.html">2.4.3. Information Module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../misc.html">2.4.4. Miscellaneous</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../MakeData.html">2.5. Make Data (MakeData) Module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../PointCloud.html">2.5.1. Point Cloud Data Generation (PointCloud) Module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../DynSysLib.html">2.5.2. Dynamic Systems Library (DynSysLib) Module</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing.html">3. Contributing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../contributing.html#contributing-to-documentation">3.1. Contributing to Documentation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../license.html">4. License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../citing.html">5. Citing</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">teaspoon</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content style-external-links">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>teaspoon.parameter_selection.MI_delay</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for teaspoon.parameter_selection.MI_delay</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Mutual Information (MI) for time delay (tau).</span>
<span class="sd">=======================================================================</span>
<span class="sd">uses mutual information to find a suitable delay via the location</span>
<span class="sd">of the first minima in the mutual information vs delay plot, which is calculated using multiple</span>
<span class="sd">x(t) vs x(t+tau) plots. These plots have their individual mutual information calculated. Various methods</span>
<span class="sd">for partitioning the x(t) vs x(t+tau) plots for calculating the mutual information.</span>
<span class="sd">&quot;&quot;&quot;</span>




<span class="k">class</span> <span class="nc">Partitions</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">meshingScheme</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">numParts</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                 <span class="n">alpha</span><span class="o">=</span><span class="mf">0.05</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">scipy</span>

        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># check that the data is in ordinal coordinates</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">isOrdinal</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Converting the data to ordinal...&quot;</span><span class="p">)</span>
                <span class="c1"># perform ordinal sampling (ranking) transformation</span>
                <span class="n">xRanked</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">rankdata</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;ordinal&#39;</span><span class="p">)</span>
                <span class="n">yRanked</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">rankdata</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;ordinal&#39;</span><span class="p">)</span>


                <span class="n">xFloats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">xFloats</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
                <span class="n">yFloats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">yFloats</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">xFloats</span> <span class="o">=</span> <span class="n">xFloats</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">yFloats</span> <span class="o">=</span> <span class="n">yFloats</span>


                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">xRanked</span><span class="p">,</span><span class="n">yRanked</span><span class="p">))</span>

                <span class="c1"># and return an empty partition bucket</span>

            <span class="c1"># If there is data, set the bounding box to be the max and min in the data</span>


            <span class="n">xmin</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="n">xmax</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">ymin</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="n">ymax</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">borders</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">borders</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">borders</span><span class="p">[</span><span class="s1">&#39;npts&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">numParts</span> <span class="o">=</span> <span class="n">numParts</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span>



            <span class="c1"># If there is data, use the chosen meshing scheme to build the partitions.</span>
            <span class="k">if</span> <span class="n">meshingScheme</span> <span class="o">==</span> <span class="s1">&#39;DV&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">isOrdinal</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                <span class="c1"># Figure out</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">partitionBucket</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_partition_DV</span><span class="p">(</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">,</span>
                                        <span class="n">borders</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">borders</span><span class="p">,</span>
                                        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numParts</span><span class="p">,</span>
                                        <span class="n">alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># meshingScheme == None</span>
            <span class="c1"># Note that right now, this will just do the dumb thing for every other input</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">partitionBucket</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">borders</span><span class="p">]</span>
                <span class="c1">#  set the partitions to just be the bounding box</span>


        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">partitionBucket</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">convertOrdToFloat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">partitionEntry</span><span class="p">):</span>
        <span class="n">bdyList</span> <span class="o">=</span> <span class="n">partitionEntry</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># Need to subtract one to deal with counting from</span>
        <span class="c1"># 0 vs counting from 1 problems</span>
        <span class="n">xLow</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">bdyList</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">xHigh</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">bdyList</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">yLow</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">bdyList</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">yHigh</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">bdyList</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span>


        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;xFloats&#39;</span><span class="p">):</span>
            <span class="n">xLowFloat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xFloats</span><span class="p">[</span><span class="n">xLow</span><span class="p">]</span>
            <span class="n">xHighFloat</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xFloats</span><span class="p">[</span><span class="n">xHigh</span><span class="p">]</span>
            <span class="n">yLowFloat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">yFloats</span><span class="p">[</span><span class="n">yLow</span><span class="p">]</span>
            <span class="n">yHighFloat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">yFloats</span><span class="p">[</span><span class="n">yHigh</span><span class="p">]</span>
            <span class="n">convertedBdyList</span> <span class="o">=</span> <span class="p">[</span><span class="n">xLowFloat</span><span class="p">,</span> <span class="n">xHighFloat</span><span class="p">,</span> <span class="n">yLowFloat</span><span class="p">,</span><span class="n">yHighFloat</span><span class="p">]</span>
            <span class="n">partitionEntry</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convertedBdyList</span>
            <span class="k">return</span> <span class="n">partitionEntry</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;You&#39;re trying to convert your ordinal data&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;back to floats, but you must have had ordinal&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;to begin with so I can&#39;t.  Exiting...&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">partitionBucket</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;xFloats&#39;</span><span class="p">):</span> <span class="c1">#if the data wasn&#39;t ordinal</span>
            <span class="n">entry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">partitionBucket</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">entry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convertOrdToFloat</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">entry</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">partitionBucket</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">getOrdinal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">key</span><span class="p">):</span>
        <span class="c1"># overrides the builtin magic method in the case where</span>
        <span class="c1"># you had non-ordinal data but still want the ordinal</span>
        <span class="c1"># stuff back.</span>
        <span class="c1"># If the data wasn&#39;t ordinal, this has the exact same</span>
        <span class="c1"># effect as self[key]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">partitionBucket</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># iterates over the converted entries in the</span>
        <span class="c1"># parameter bucket</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;xFloats&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">map</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">convertOrdToFloat</span><span class="p">,</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">partitionBucket</span><span class="p">)</span>  <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">partitionBucket</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">iterOrdinal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># functions just like iter magic method without</span>
        <span class="c1"># converting each entry back to its float</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">partitionBucket</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;!</span>
<span class="sd">        @brief Nicely prints all currently set values in the bucket.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="nb">vars</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="n">output</span> <span class="o">+=</span> <span class="s1">&#39;Variables in partition bucket</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">output</span> <span class="o">+=</span> <span class="s1">&#39;---</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">attrs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">output</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; : &#39;</span>
            <span class="n">output</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="n">key</span><span class="p">])</span><span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="n">output</span> <span class="o">+=</span> <span class="s1">&#39;---</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="k">return</span> <span class="n">output</span>

    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="kn">import</span> <span class="nn">matplotlib</span>
        <span class="c1"># plot the partitions</span>
        <span class="n">fig1</span><span class="p">,</span> <span class="n">ax1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">binNode</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="c1"># print(binNode)</span>
            <span class="c1"># get the bottom left corner</span>
            <span class="n">corner</span> <span class="o">=</span> <span class="p">(</span><span class="n">binNode</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">binNode</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span>

            <span class="c1"># get the width and height</span>
            <span class="n">width</span> <span class="o">=</span> <span class="n">binNode</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">binNode</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">height</span> <span class="o">=</span> <span class="n">binNode</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">binNode</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>

            <span class="c1"># add the corresponding rectangle</span>
            <span class="n">ax1</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">patches</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">(</span><span class="n">corner</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>

        <span class="c1"># Doesn&#39;t show unless we do this</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>

    <span class="c1"># helper function for error checking. Used to make sure input is in</span>
    <span class="c1"># ordinarl coordinates. It checks that when the two data columns are sorted</span>
    <span class="c1"># they are each equal to an ordered vector with the same number of rows.</span>
    <span class="k">def</span> <span class="nf">isOrdinal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dd</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">stop</span><span class="o">=</span><span class="n">dd</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span>
                                             <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="n">dd</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">))))</span>




    <span class="c1"># data: is a manyx2 numpy array that contains all the original data</span>
    <span class="c1"># borders: a dictionary that contains &#39;nodes&#39; with a numpyu array of Xmin, Xmax, Ymin, Ymax,</span>
    <span class="c1"># and &#39;npts&#39; which contains the number of points in the bin</span>
    <span class="c1"># r: is the number of partitions</span>
    <span class="c1"># alpha: the significance level to test for independence</span>
    <span class="k">def</span> <span class="nf">return_partition_DV</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">borders</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.05</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">scipy</span>
        <span class="c1"># extract the bin boundaries</span>
        <span class="n">Xmin</span> <span class="o">=</span> <span class="n">borders</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">Xmax</span> <span class="o">=</span> <span class="n">borders</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">Ymin</span> <span class="o">=</span> <span class="n">borders</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">Ymax</span> <span class="o">=</span> <span class="n">borders</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span>

        <span class="c1"># find the number of bins</span>
    <span class="c1">#    numBins = r ** 2</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">Xmin</span><span class="p">)</span>
                       <span class="o">&amp;</span> <span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">Xmax</span> <span class="p">)</span>
                       <span class="o">&amp;</span> <span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">Ymin</span><span class="p">)</span>
                       <span class="o">&amp;</span> <span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">Ymax</span><span class="p">))</span>

        <span class="c1"># extract the points in the bin</span>
        <span class="n">Xsub</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">Ysub</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

    <span class="c1">#    print(Xsub.shape, &#39;\t&#39;, Ysub.shape)</span>

        <span class="c1"># find the indices of the points in the x- and y-patches</span>
        <span class="n">idx_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">Xmin</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">Xmax</span><span class="p">))</span>
        <span class="n">idx_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">Ymin</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">Ymax</span><span class="p">))</span>

        <span class="c1"># get the subpartitions</span>
        <span class="n">ai</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">idx_x</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="o">/</span><span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span><span class="p">))</span>
        <span class="n">bj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">idx_y</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="o">/</span><span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span><span class="p">))</span>

        <span class="c1"># get the bin edges</span>
        <span class="n">edges1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="n">Xmin</span><span class="p">],</span> <span class="n">ai</span><span class="p">,</span> <span class="p">[</span><span class="n">Xmax</span><span class="p">]))</span>
        <span class="n">edges2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="n">Ymin</span><span class="p">],</span> <span class="n">bj</span><span class="p">,</span> <span class="p">[</span><span class="n">Ymax</span><span class="p">]))</span>

        <span class="c1"># first exit criteria: we cannot split inot unique boundaries any more</span>
        <span class="c1"># preallocate the partition list</span>
        <span class="n">partitions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">edges1</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span> <span class="ow">or</span>
             <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">edges2</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span><span class="o">&lt;</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>

            <span class="c1"># reject futher partitions, and return original bin</span>
            <span class="n">partitions</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;nodes&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Xmin</span><span class="p">,</span> <span class="n">Xmax</span><span class="p">,</span> <span class="n">Ymin</span><span class="p">,</span> <span class="n">Ymax</span><span class="p">]),</span>
                      <span class="s1">&#39;npts&#39;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">])})</span>
            <span class="k">return</span> <span class="n">partitions</span>

        <span class="c1"># figure out the shift in the edges so that boundaries do not overlap</span>
        <span class="n">xShift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">r</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">r</span><span class="p">))</span>
        <span class="n">yShift</span> <span class="o">=</span> <span class="n">xShift</span>
        <span class="n">xShift</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]),</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">r</span><span class="p">,</span> <span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">yShift</span> <span class="o">=</span> <span class="n">xShift</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># find the boundaries for each bin</span>
        <span class="c1"># duplicate inner nodes for x mesh</span>
        <span class="n">dupMidNodesX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">((</span><span class="n">edges1</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                                          <span class="mi">0</span><span class="p">,</span> <span class="n">edges1</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">edges1</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># duplicate inner nodes for y mesh</span>
        <span class="n">dupMidNodesY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">((</span><span class="n">edges2</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                                          <span class="mi">0</span><span class="p">,</span> <span class="n">edges2</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">edges2</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># reshape</span>
        <span class="n">dupMidNodesY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">dupMidNodesY</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c1"># now find the nodes for each bin</span>
        <span class="n">xBinBound</span> <span class="o">=</span> <span class="n">dupMidNodesX</span> <span class="o">+</span> <span class="n">xShift</span>
        <span class="n">yBinBound</span> <span class="o">=</span> <span class="n">dupMidNodesY</span> <span class="o">+</span> <span class="n">yShift</span>
        <span class="c1"># find the number of points in each bin, and put this info into array</span>
        <span class="n">binned_data</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">binned_statistic_2d</span><span class="p">(</span><span class="n">Xsub</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">Ysub</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;count&#39;</span><span class="p">,</span>
                                          <span class="n">bins</span><span class="o">=</span><span class="p">[</span><span class="n">edges1</span><span class="p">,</span> <span class="n">edges2</span><span class="p">])</span>
        <span class="c1"># get the counts. Flatten columnwise to match the bin definition in the</span>
        <span class="c1"># loop that creates the dictionaries below</span>
        <span class="n">binCounts</span> <span class="o">=</span> <span class="n">binned_data</span><span class="o">.</span><span class="n">statistic</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>

        <span class="c1"># define an empty list to hold the dictionaries of the fresh partitions</span>
        <span class="n">bins</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># create dictionaries for each bin</span>
        <span class="c1"># start with the loop over y</span>
        <span class="c1"># note how the loop counts were obtained above to match the convention</span>
        <span class="c1"># here</span>
        <span class="k">for</span> <span class="n">yInd</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
            <span class="c1"># this is the loop over x</span>
            <span class="k">for</span> <span class="n">xInd</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
                <span class="c1"># get the bin number</span>
                <span class="n">binNo</span> <span class="o">=</span> <span class="n">yInd</span> <span class="o">*</span> <span class="n">r</span>  <span class="o">+</span> <span class="n">xInd</span>
                <span class="n">xLow</span><span class="p">,</span> <span class="n">xHigh</span> <span class="o">=</span> <span class="n">xBinBound</span><span class="p">[</span><span class="n">yInd</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">xInd</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>
                <span class="n">yLow</span><span class="p">,</span> <span class="n">yHigh</span> <span class="o">=</span> <span class="n">yBinBound</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">yInd</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">xInd</span><span class="p">]</span>
                <span class="n">bins</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;nodes&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xLow</span><span class="p">,</span> <span class="n">xHigh</span><span class="p">,</span> <span class="n">yLow</span><span class="p">,</span> <span class="n">yHigh</span><span class="p">]),</span>
                    <span class="s1">&#39;npts&#39;</span><span class="p">:</span> <span class="n">binCounts</span><span class="p">[</span><span class="n">binNo</span><span class="p">]</span> <span class="p">})</span>

        <span class="c1"># calculate the chi square statistic</span>
        <span class="n">chi2</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">chisquare</span><span class="p">(</span><span class="n">binCounts</span><span class="p">)</span>

        <span class="c1"># check for independence and start recursion</span>
        <span class="c1"># if the chi2 test fails, do further partitioning:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">chi2</span><span class="o">.</span><span class="n">pvalue</span> <span class="o">&lt;</span> <span class="n">alpha</span> <span class="ow">and</span> <span class="n">Xmax</span><span class="o">!=</span><span class="n">Xmin</span> <span class="ow">and</span> <span class="n">Ymax</span><span class="o">!=</span><span class="n">Ymin</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">binInfo</span> <span class="ow">in</span> <span class="n">bins</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">binInfo</span><span class="p">[</span><span class="s1">&#39;npts&#39;</span><span class="p">]</span> <span class="o">!=</span><span class="mi">0</span><span class="p">:</span>  <span class="c1"># if the bin is not empty:</span>
                    <span class="c1"># append entries to the tuple</span>
                    <span class="n">partitions</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">return_partition_DV</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                                                            <span class="n">borders</span><span class="o">=</span><span class="n">binInfo</span><span class="p">,</span>
                                                            <span class="n">r</span><span class="o">=</span><span class="n">r</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">))</span>

        <span class="c1"># Second exit criteria:</span>
        <span class="c1"># if the partitions are independent, reject further partitioning and</span>
        <span class="c1"># save the orignal, unpartitioned bin</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">partitions</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;nodes&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Xmin</span><span class="p">,</span> <span class="n">Xmax</span><span class="p">,</span> <span class="n">Ymin</span><span class="p">,</span> <span class="n">Ymax</span><span class="p">]),</span>
                      <span class="s1">&#39;npts&#39;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">])})</span>

        <span class="k">return</span> <span class="n">partitions</span>


<span class="c1"># In[ ]:</span>


<div class="viewcode-block" id="MI_DV"><a class="viewcode-back" href="../../../MI.html#teaspoon.parameter_selection.MI_delay.MI_DV">[docs]</a><span class="k">def</span> <span class="nf">MI_DV</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> 
    <span class="sd">&quot;&quot;&quot;This function calculates the mutual information between the time series x(t) and its delayed version x(t+tau)</span>
<span class="sd">    using adaptive partitioning of the plots of the time series x(t) and its delayed version x(t+tau). </span>
<span class="sd">    This method was developed by Georges Darbellay and Igor Vajda in 1999 and was published as</span>
<span class="sd">    Estimation of information by an adaptive partitioning of the observation.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">       x (array): time series x(t)</span>
<span class="sd">       y (array): delayed time series x(t + tau) </span>

<span class="sd">    Returns:</span>
<span class="sd">       (float): I, mutual information between x(t) and x(t+tau).</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#input: x: x cooridnate array (could be time array), y: y coorindate array (could be time series)</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
    <span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">rankdata</span>

    <span class="c1"># perform ordinal sampling (ranking) transformation</span>
    <span class="n">xRanked</span> <span class="o">=</span> <span class="n">rankdata</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;ordinal&#39;</span><span class="p">)</span>
    <span class="n">yRanked</span> <span class="o">=</span> <span class="n">rankdata</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;ordinal&#39;</span><span class="p">)</span>
    
    <span class="c1"># obtain the adaptive mesh</span>
    <span class="n">numParts</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="c1"># get the adaptive partition of the data</span>
    <span class="n">partitionList</span> <span class="o">=</span> <span class="n">Partitions</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">xRanked</span><span class="p">,</span> <span class="n">yRanked</span><span class="p">)),</span> <span class="n">meshingScheme</span> <span class="o">=</span> <span class="s2">&quot;DV&quot;</span><span class="p">,</span> <span class="n">numParts</span><span class="o">=</span><span class="n">numParts</span><span class="p">)</span>
    <span class="c1">#partitions are sorted in class as:</span>
    <span class="c1">#1. overall borders with number of points total: xmin, xmax, ymin, ymax</span>
    <span class="c1">#2. numParts = max number of parts in a single bin/partition</span>
    <span class="c1">#3. alpha</span>
    <span class="c1">#4. partition bucket: this has all the partition&#39;s borders and number of points in each.</span>

    <span class="c1"># extract the bin counts</span>
    <span class="n">binCounts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">partitionList</span><span class="o">.</span><span class="n">partitionBucket</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;npts&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">partitionList</span><span class="p">))])</span>

    <span class="c1"># get the total number of points</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">partitionList</span><span class="o">.</span><span class="n">borders</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;npts&quot;</span><span class="p">)</span>
    
    <span class="c1"># grab the probability information from the partition</span>
    <span class="n">Pn_AB</span> <span class="o">=</span> <span class="n">binCounts</span> <span class="o">/</span> <span class="n">N</span>

    <span class="c1"># grab the probbility of the horizontal strips for each bin</span>
    <span class="n">PC</span> <span class="o">=</span> <span class="n">partitionList</span> <span class="c1">#partition cells</span>
    
    <span class="n">Pn_AR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">partitionList</span><span class="p">))</span>
    <span class="n">Pn_RB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">partitionList</span><span class="p">))</span>
    
    <span class="k">for</span> <span class="n">Bin</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">partitionList</span><span class="p">)):</span> <span class="c1">#go through each bin</span>
        <span class="n">Pn_AR</span><span class="p">[</span><span class="n">Bin</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">xRanked</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="c1">#count number of point between x bounds of bin</span>
            <span class="k">if</span> <span class="n">xRanked</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">PC</span><span class="p">[</span><span class="n">Bin</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;nodes&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">xRanked</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">PC</span><span class="p">[</span><span class="n">Bin</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;nodes&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">Pn_RB</span><span class="p">[</span><span class="n">Bin</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">yRanked</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="c1">#count number of point between y bounds of bin</span>
            <span class="k">if</span> <span class="n">yRanked</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">PC</span><span class="p">[</span><span class="n">Bin</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;nodes&#39;</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">and</span> <span class="n">yRanked</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">PC</span><span class="p">[</span><span class="n">Bin</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;nodes&#39;</span><span class="p">)[</span><span class="mi">3</span><span class="p">]])</span>
    <span class="n">Pn_AR</span> <span class="o">=</span> <span class="p">(</span><span class="n">Pn_AR</span><span class="p">)</span><span class="o">/</span><span class="n">N</span> <span class="c1">#divide for probability</span>
    <span class="n">Pn_RB</span> <span class="o">=</span> <span class="p">(</span><span class="n">Pn_RB</span><span class="p">)</span><span class="o">/</span><span class="n">N</span>
    
    <span class="c1"># find the approximation for the mutual information function</span>
    <span class="n">Iapprox</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Pn_AB</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">Pn_AB</span><span class="o">/</span><span class="p">(</span><span class="n">Pn_AR</span><span class="o">*</span><span class="n">Pn_RB</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">Iapprox</span></div>

<span class="c1"># This function computes the mutual information function based on the</span>
<span class="c1"># algorithm described in:</span>
<span class="c1"># &quot;Estimating Mutual Information,&quot; Alexander Kraskov, Harald Stoegbauer, Peter Grassberger, 2003.</span>
    
<div class="viewcode-block" id="MI_kraskov"><a class="viewcode-back" href="../../../MI.html#teaspoon.parameter_selection.MI_delay.MI_kraskov">[docs]</a><span class="k">def</span> <span class="nf">MI_kraskov</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ranking</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This function estimates the mutual information between the time series x(t) and its delayed version x(t+tau) in two different ways. </span>
<span class="sd">    This method was developed by Alexander Kraskov, Harald Stoegbauer, and Peter Grassberger in 2003 and published as </span>
<span class="sd">    Estimating Mutual Information.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">       x (array): time series x(t)</span>
<span class="sd">       y (array): delayed time series x(t + tau) </span>
<span class="sd">       </span>
<span class="sd">    Kwargs:</span>
<span class="sd">       k (int): number of nearest neighbors used in MI estimation. Default is k = 2.</span>
<span class="sd">       </span>
<span class="sd">       ranking (bool): whether the ranked or unranked x and y inputs will be used. Default is ranking = True.</span>
<span class="sd">       </span>
<span class="sd">    Returns:</span>
<span class="sd">       (float): I1, first mutual information estimation method between x(t) and x(t+tau).</span>
<span class="sd">       (float): I2, second mutual information estimation method between x(t) and x(t+tau).</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">ranking</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span> <span class="c1">#rank x and y ordinally</span>
        <span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">rankdata</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">rankdata</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;ordinal&#39;</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">rankdata</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;ordinal&#39;</span><span class="p">)</span>
        
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
    <span class="c1"># put into a column vector and perturb the data to improve uniqueness</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="c1">#+ (10**-5)*np.random.random_sample((len(x),))</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="c1">#+ (10**-5)*np.random.random_sample((len(y),))</span>
    
    <span class="n">lenZ</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="c1">#find nearest neighbors in s-q plane using the chebyshev distance</span>
    <span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="kn">import</span> <span class="n">NearestNeighbors</span>
    <span class="n">vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
    <span class="n">nbrs</span> <span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;ball_tree&#39;</span><span class="p">,</span> <span class="n">metric</span> <span class="o">=</span> <span class="s1">&#39;chebyshev&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span>
    <span class="n">distances</span><span class="p">,</span> <span class="n">indZ</span> <span class="o">=</span> <span class="n">nbrs</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span>
    <span class="c1"># from the subset of nearest neighbors, find the distance to the kth nearest neighbor after</span>
    <span class="c1"># projecting the points on each axis</span>
    <span class="n">cDx</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">indZ</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="n">indZ</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">]),(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">indZ</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="mi">1</span><span class="p">)),</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">cDx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">cDx</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">cDy</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">indZ</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">y</span><span class="p">[</span><span class="n">indZ</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">]),(</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">indZ</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="mi">1</span><span class="p">)),</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">cDy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">cDy</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1">#finding closest nearest kth neighbor distance for each node</span>
    <span class="n">cD</span> <span class="o">=</span> <span class="n">distances</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    

    <span class="c1">#METHOD 1</span>
    <span class="c1">#find number of points (s-q plane) that fall within strips with widths defined by cDx and cDy</span>
    <span class="n">nxI</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">nyI</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">x_d</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="mi">1</span><span class="p">)),</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">-</span> <span class="n">x</span><span class="p">))</span> <span class="c1">#array of distances in x from point i</span>
    <span class="n">y_d</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">),</span><span class="mi">1</span><span class="p">)),</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">))</span> <span class="o">-</span> <span class="n">y</span><span class="p">))</span> <span class="c1">#array of distances in y from point i</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cDx</span><span class="p">)):</span>
        <span class="n">nxI</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x_d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">x_d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">cD</span><span class="p">[</span><span class="n">i</span><span class="p">]]))</span>
        <span class="n">nyI</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y_d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">y_d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">cD</span><span class="p">[</span><span class="n">i</span><span class="p">]]))</span>
    <span class="n">nxI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nxI</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">nyI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nyI</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    
    <span class="c1">#METHOD 2</span>
    <span class="c1">#find number of points falling within epsilon/2 in x and y </span>
    <span class="n">nxI2</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">nyI2</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cDx</span><span class="p">)):</span>
        <span class="n">nxI2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x_d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">x_d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;=</span><span class="p">(</span><span class="n">cDx</span><span class="p">[</span><span class="n">i</span><span class="p">])]))</span> <span class="c1">#append if distance is less than epsilon_x/2</span>
        <span class="n">nyI2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y_d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">y_d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;=</span><span class="p">(</span><span class="n">cDy</span><span class="p">[</span><span class="n">i</span><span class="p">])]))</span> <span class="c1">#append if distance is less than epsilon_y/2</span>
    <span class="n">nxI2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nxI2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1">#subtract one for self</span>
    <span class="n">nyI2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nyI2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1">#subtract one for self</span>
    
    <span class="c1">#compute the mutual information function using the digamma function</span>
    <span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">digamma</span>
    <span class="c1"># alogirthm 1 mutual information:</span>
    <span class="n">I1</span> <span class="o">=</span> <span class="n">digamma</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">digamma</span><span class="p">(</span><span class="n">nxI</span> <span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">digamma</span><span class="p">(</span><span class="n">nyI</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="n">digamma</span><span class="p">(</span><span class="n">lenZ</span><span class="p">)</span>
    <span class="c1"># algorithm 2 mutual information</span>
    <span class="n">I2</span> <span class="o">=</span> <span class="n">digamma</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">k</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">digamma</span><span class="p">(</span><span class="n">nxI2</span><span class="p">)</span> <span class="o">+</span> <span class="n">digamma</span><span class="p">(</span><span class="n">nyI2</span><span class="p">))</span> <span class="o">+</span> <span class="n">digamma</span><span class="p">(</span><span class="n">lenZ</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">I1</span><span class="p">,</span> <span class="n">I2</span></div>


<span class="c1"># This function computes the mutual information function based on</span>
<span class="c1"># equal sized bins for x and y arrays (seperately)</span>

<div class="viewcode-block" id="MI_basic"><a class="viewcode-back" href="../../../MI.html#teaspoon.parameter_selection.MI_delay.MI_basic">[docs]</a><span class="k">def</span> <span class="nf">MI_basic</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">h_method</span> <span class="o">=</span> <span class="s1">&#39;sturge&#39;</span><span class="p">,</span> <span class="n">ranking</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span> 
    <span class="sd">&quot;&quot;&quot;This function calculates the mutual information between the time series x(t) and its delayed version x(t+tau)</span>
<span class="sd">    using equi-spaced partitions. The size of the partition is based on the desired bin size method commonly selected for histograms.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">       x (array): time series x(t)</span>
<span class="sd">       y (array): delayed time series x(t + tau) </span>
<span class="sd">       </span>
<span class="sd">    Kwargs:</span>
<span class="sd">       h_method (string): bin size selection method. Methods are struge, sqrt, or rice. Default is sturge.</span>
<span class="sd">       </span>
<span class="sd">       ranking (bool): whether the ranked or unranked x and y inputs will be used. Default is ranking = True.</span>

<span class="sd">    Returns:</span>
<span class="sd">       (float): I, mutual information between x(t) and x(t+tau).</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#input: x: x array (could be time array), y: y array (could be time series)</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
    <span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">rankdata</span>
    
    <span class="c1">#number of points</span>
    <span class="n">Nx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> 
    <span class="n">Ny</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Nx</span> <span class="o">==</span> <span class="n">Ny</span><span class="p">:</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">Nx</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">Nx</span><span class="p">,</span><span class="n">Ny</span><span class="p">])</span>

    <span class="c1"># perform ordinal sampling (ranking) transformation</span>
    <span class="k">if</span> <span class="n">ranking</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">rankdata</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;ordinal&#39;</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">rankdata</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;ordinal&#39;</span><span class="p">)</span>
    
    
    <span class="c1">#first find number of bins based on given method</span>
    <span class="c1">#Either Sturge&#39;s or Rice Rule provides the most acurate results so far</span>
    <span class="c1">#strurges works better for smaller data sets </span>
    <span class="k">if</span> <span class="n">h_method</span> <span class="o">==</span> <span class="s1">&#39;sturge&#39;</span><span class="p">:</span>
        <span class="n">Bx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">Nx</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">By</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">Ny</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">B</span> <span class="o">=</span> <span class="p">[</span><span class="n">Bx</span><span class="p">,</span> <span class="n">By</span><span class="p">]</span>
        
    <span class="k">if</span> <span class="n">h_method</span> <span class="o">==</span> <span class="s1">&#39;sqrt&#39;</span><span class="p">:</span>
        <span class="n">Bx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Nx</span><span class="p">)</span>
        <span class="n">By</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Ny</span><span class="p">)</span>
        <span class="n">B</span> <span class="o">=</span> <span class="p">[</span><span class="n">Bx</span><span class="p">,</span> <span class="n">By</span><span class="p">]</span>
        
    <span class="k">if</span> <span class="n">h_method</span> <span class="o">==</span> <span class="s1">&#39;rice&#39;</span><span class="p">:</span>
        <span class="n">Bx</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">Nx</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">))</span>
        <span class="n">By</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">Ny</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">))</span>
        <span class="n">B</span> <span class="o">=</span> <span class="p">[</span><span class="n">Bx</span><span class="p">,</span> <span class="n">By</span><span class="p">]</span>
        
    <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">B</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    
    <span class="c1">#calculates 1D histogram for both x and y seperately</span>
    <span class="n">Hx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">bins</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">Hy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">bins</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">B</span><span class="p">[</span><span class="mi">1</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>    
    
    <span class="c1">#calculates histogram for 2D data on s-q plot with given number of bins</span>
    <span class="n">Hxy</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">histogram2d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">bins</span> <span class="o">=</span> <span class="n">B</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">Px</span> <span class="o">=</span> <span class="n">Hx</span><span class="o">/</span><span class="n">N</span>
    <span class="n">Py</span> <span class="o">=</span> <span class="n">Hy</span><span class="o">/</span><span class="n">N</span>
    <span class="n">Pxy</span> <span class="o">=</span> <span class="n">Hxy</span><span class="o">/</span><span class="n">N</span>
    
    <span class="n">I_matrix</span> <span class="o">=</span> <span class="n">Pxy</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">Pxy</span><span class="o">/</span><span class="p">(</span><span class="n">Px</span><span class="o">*</span><span class="n">Py</span><span class="p">))</span>
    <span class="n">where_are_NaNs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">I_matrix</span><span class="p">)</span>
    <span class="n">I_matrix</span><span class="p">[</span><span class="n">where_are_NaNs</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">I</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">I_matrix</span><span class="p">))</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">I</span><span class="p">)</span></div>


<div class="viewcode-block" id="MI_for_delay"><a class="viewcode-back" href="../../../MI.html#teaspoon.parameter_selection.MI_delay.MI_for_delay">[docs]</a><span class="k">def</span> <span class="nf">MI_for_delay</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">plotting</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;basic&#39;</span><span class="p">,</span> <span class="n">h_method</span> <span class="o">=</span> <span class="s1">&#39;sturge&#39;</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ranking</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This function calculates the mutual information until a first minima is reached, which is estimated as a sufficient embedding dimension for permutation entropy.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">       ts (array):  Time series (1d).</span>

<span class="sd">    Kwargs:</span>
<span class="sd">       plotting (bool): Plotting for user interpretation. defaut is False.</span>
<span class="sd">       </span>
<span class="sd">       method (string): Method for calculating MI. Options include basic, kraskov 1, kraskov 2, or adaptive partitions. Default is basic.</span>
<span class="sd">       </span>
<span class="sd">       h_method (string): Bin size selection method for basic method. Methods are struge, sqrt, or rice. Default is sturge.</span>
<span class="sd">       </span>
<span class="sd">       ranking (bool): Whether the ranked or unranked x and y inputs will be used for kraskov and basic methods. Default is ranking = True.</span>
<span class="sd">       </span>
<span class="sd">       k (int): Number of nearest neighbors used in MI estimation for Kraskov methods. Default is k = 2.</span>

<span class="sd">    Returns:</span>
<span class="sd">       (int): tau, The embedding delay for permutation formation based on first mutual information minima.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">delayMax</span> <span class="o">=</span> <span class="mi">250</span>
    <span class="n">min_flag</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">I</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1">#initializes information array</span>
    <span class="n">tau</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">delay</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">method_flag</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">while</span> <span class="n">delay</span> <span class="o">&lt;</span> <span class="n">delayMax</span> <span class="ow">and</span> <span class="n">min_flag</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">delay</span> <span class="o">=</span> <span class="n">delay</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;adaptive partitions&#39;</span><span class="p">:</span>
            <span class="n">method_flag</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">x</span>  <span class="o">=</span> <span class="n">ts</span><span class="p">[:</span><span class="o">-</span><span class="n">delay</span><span class="p">]</span> <span class="c1">#takes all terms from time series besides last (delay) terms</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">ts</span><span class="p">[</span><span class="n">delay</span><span class="p">:]</span> <span class="c1">#takes all terms from time series besides first (delay) terms</span>
            <span class="n">I</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">MI_DV</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span> 
            <span class="n">tau</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">delay</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;kraskov 1&#39;</span><span class="p">:</span>
            <span class="n">method_flag</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">x</span>  <span class="o">=</span> <span class="n">ts</span><span class="p">[:</span><span class="o">-</span><span class="n">delay</span><span class="p">]</span> <span class="c1">#takes all terms from time series besides last (delay) terms</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">ts</span><span class="p">[</span><span class="n">delay</span><span class="p">:]</span> <span class="c1">#takes all terms from time series besides first (delay) terms</span>
            <span class="n">MI_k</span> <span class="o">=</span> <span class="n">MI_kraskov</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="n">I</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">MI_k</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> 
            <span class="n">tau</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">delay</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;kraskov 2&#39;</span><span class="p">:</span>
            <span class="n">method_flag</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">x</span>  <span class="o">=</span> <span class="n">ts</span><span class="p">[:</span><span class="o">-</span><span class="n">delay</span><span class="p">]</span> <span class="c1">#takes all terms from time series besides last (delay) terms</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">ts</span><span class="p">[</span><span class="n">delay</span><span class="p">:]</span> <span class="c1">#takes all terms from time series besides first (delay) terms</span>
            <span class="n">MI_k</span> <span class="o">=</span> <span class="n">MI_kraskov</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="n">I</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">MI_k</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> 
            <span class="n">tau</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">delay</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;basic&#39;</span><span class="p">:</span>
            <span class="n">method_flag</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">x</span>  <span class="o">=</span> <span class="n">ts</span><span class="p">[:</span><span class="o">-</span><span class="n">delay</span><span class="p">]</span> <span class="c1">#takes all terms from time series besides last (delay) terms</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">ts</span><span class="p">[</span><span class="n">delay</span><span class="p">:]</span> <span class="c1">#takes all terms from time series besides first (delay) terms</span>
            <span class="n">I</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">MI_basic</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span> 
            <span class="n">tau</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">delay</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">delay</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">delay</span> <span class="o">==</span> <span class="n">delayMax</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">I</span><span class="p">[</span><span class="n">delay</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">I</span><span class="p">[</span><span class="n">delay</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">delay</span> <span class="o">==</span> <span class="n">delayMax</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="c1">#if increasing</span>
                <span class="n">delay_at_min</span> <span class="o">=</span> <span class="n">delay</span>
                <span class="n">min_flag</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">method_flag</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: invalid method entered.&#39;</span><span class="p">)</span>
            <span class="k">break</span><span class="p">;</span>
    <span class="k">if</span> <span class="n">plotting</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
        <span class="n">TextSize</span> <span class="o">=</span> <span class="mi">18</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">tau</span><span class="p">,</span><span class="n">I</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="n">method</span><span class="o">+</span> <span class="s1">&#39;: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">delay_at_min</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\tau$&#39;</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="n">TextSize</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;MI&#39;</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="n">TextSize</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">size</span> <span class="o">=</span> <span class="n">TextSize</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">yticks</span><span class="p">(</span><span class="n">size</span> <span class="o">=</span> <span class="n">TextSize</span><span class="p">)</span>
        <span class="c1">#plt.legend(loc = &#39;upper right&#39;, fontsize = TextSize)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">delay_at_min</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span></div>
<span class="c1"># In[ ]:</span>
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    
    <span class="kn">from</span> <span class="nn">teaspoon.parameter_selection.MI_delay</span> <span class="kn">import</span> <span class="n">MI_for_delay</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
    
    <span class="n">fs</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">fs</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span>
    <span class="n">ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">((</span><span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
    
    <span class="n">tau</span> <span class="o">=</span> <span class="n">MI_for_delay</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">plotting</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;basic&#39;</span><span class="p">,</span> <span class="n">h_method</span> <span class="o">=</span> <span class="s1">&#39;sturge&#39;</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ranking</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Delay from MI: &#39;</span><span class="p">,</span><span class="n">tau</span><span class="p">)</span>


    

    
    
    
    
    
    
    
    


</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Munch

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
    <!-- Theme Analytics -->
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-XXXXXXX-1', 'auto');
    ga('send', 'pageview');
    </script>

    
   

</body>
</html>