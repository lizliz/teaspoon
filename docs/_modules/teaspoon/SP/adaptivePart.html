<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>teaspoon.SP.adaptivePart &mdash; teaspoon 0.1.0 documentation</title><link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: white" >
            <a href="../../../index.html" class="icon icon-home"> teaspoon<img src="../../../_static/teaspoon.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">1. Getting Started</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../installation.html#requirements">1.1. Requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../installation.html#installation">1.2. Installation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../modules.html">2. Modules</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../parameter_selection.html">2.1. Parameter Selection Module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../MI.html">2.1.1. Mutual Information</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../AC.html">2.1.2. Auto-correlation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../FSA.html">2.1.3. Fourier Spectrum Analysis</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../PAMI.html">2.1.4. Permutation Auto Mutual Information</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../MsPE.html">2.1.5. Multi-scale Permutation Entropy</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../FNN.html">2.1.6. False Nearest Neighbors</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../ML.html">2.2. Machine Learning (ML) Module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../F_PD.html">2.2.1. Featurization</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../CL.html">2.2.2. Classification</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../ML.html#references">2.2.3. References</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../TDA.html">2.3. Topological Data Analaysis (TDA) Module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../PHN.html">2.3.1. Persistent Homology of Networks (PHN) Module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../distances.html">2.3.2. Distances</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../drawing.html">2.3.3. Drawing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../persistence.html">2.3.4. Persistence</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../sublevel_set_persistence.html">2.3.5. Zero Dimensional Sublevel Set Persistence (SLSP) Module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../SP.html">2.4. Signal Processing (SP) Module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../tsa.html">2.4.1. Time Series Analysis (TSA) Tools</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../network.html">2.4.2. Network Representation of Time Series</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../information.html">2.4.3. Information Module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../misc.html">2.4.4. Miscellaneous</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../MakeData.html">2.5. Make Data (MakeData) Module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../PointCloud.html">2.5.1. Point Cloud Data Generation (PointCloud) Module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../DynSysLib.html">2.5.2. Dynamic Systems Library (DynSysLib) Module</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing.html">3. Contributing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../contributing.html#contributing-to-documentation">3.1. Contributing to Documentation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../license.html">4. License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../citing.html">5. Citing</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: white" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">teaspoon</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content style-external-links">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>teaspoon.SP.adaptivePart</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for teaspoon.SP.adaptivePart</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Methods of partitioning birth-lifetime plane for persistence diagrams. This is</span>
<span class="sd">used for the adaptive partitioning version of template function featurization.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># Created on Tue Aug 14 09:35:30 2018</span>
<span class="c1">#</span>
<span class="c1"># @author: khasawn3</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">binned_statistic_2d</span><span class="p">,</span> <span class="n">chisquare</span><span class="p">,</span> <span class="n">rankdata</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">matplotlib.patches</span> <span class="k">as</span> <span class="nn">patches</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="kn">import</span> <span class="n">KMeans</span><span class="p">,</span> <span class="n">MiniBatchKMeans</span>


<div class="viewcode-block" id="Partitions"><a class="viewcode-back" href="../../../misc.html#teaspoon.SP.adaptivePart.Partitions">[docs]</a><span class="k">class</span> <span class="nc">Partitions</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    A data structure for storing a partition coming from an adapative meshing scheme.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        data (np.array):</span>
<span class="sd">            A numpy array of type many by 2</span>

<span class="sd">        convertToOrd (bool):</span>
<span class="sd">            Boolean variable to decide if you want to use ordinals for</span>
<span class="sd">            partitioning. Ordinals make things faster but not as nice partitions.</span>

<span class="sd">        meshingScheme (str):</span>
<span class="sd">            The type of meshing scheme you want to use. Options include:</span>

<span class="sd">                - &#39;DV&#39; method is based on (mention paper here). For more details see function return_partition_DV.</span>
<span class="sd">                - &#39;clustering&#39; uses a clustering algorithm to find clusters in the data, then takes the bounding box of all points assigned to each cluster. For more details see the function return_partition_clustering.</span>

<span class="sd">        partitionParams (dict):</span>
<span class="sd">            Dictionary of parameters needed for the particular meshing scheme selected.</span>
<span class="sd">            For the explanation of the parameters see the function for the specific meshingScheme</span>
<span class="sd">            (i.e. return_partition_DV or return_partition_clustering)</span>

<span class="sd">                - For &#39;DV&#39; the adjustable parameters are &#39;alpha&#39;, &#39;c&#39;, &#39;nmin&#39;, &#39;numParts&#39;, &#39;split&#39;.</span>
<span class="sd">                - For &#39;clustering&#39; the adjustable parameters are &#39;numClusters&#39;, &#39;clusterAlg&#39;, &#39;weights&#39;, &#39;boxOption&#39;, &#39;boxWidth&#39;, &#39;split&#39;.</span>

<span class="sd">        kwargs:</span>
<span class="sd">            Any leftover inputs are stored as attributes.</span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">convertToOrd</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">meshingScheme</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">partitionParams</span><span class="o">=</span><span class="p">{},</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">convertToOrd</span> <span class="o">=</span> <span class="n">convertToOrd</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meshingScheme</span> <span class="o">=</span> <span class="n">meshingScheme</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="c1"># # if using kmeans, we dont want to convert to ordinals</span>
            <span class="k">if</span> <span class="n">meshingScheme</span> <span class="o">==</span> <span class="s1">&#39;DV&#39;</span><span class="p">:</span>
                <span class="n">convertToOrd</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># check if we want to convert to ordinals</span>
            <span class="c1"># may not want to for certain partitioning schemes</span>
            <span class="k">if</span> <span class="n">convertToOrd</span><span class="p">:</span>
                <span class="c1"># check that the data is in ordinal coordinates</span>
                <span class="c1"># data converted to ordinal and stored locally if not already</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">isOrdinal</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Converting the data to ordinal...&quot;</span><span class="p">)</span>

                    <span class="c1"># perform ordinal sampling (ranking) transformation</span>
                    <span class="n">xRanked</span> <span class="o">=</span> <span class="n">rankdata</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;ordinal&#39;</span><span class="p">)</span>
                    <span class="n">yRanked</span> <span class="o">=</span> <span class="n">rankdata</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;ordinal&#39;</span><span class="p">)</span>

                    <span class="c1"># copy original data and save</span>
                    <span class="n">xFloats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
                    <span class="n">xFloats</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
                    <span class="n">yFloats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="n">yFloats</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">xFloats</span> <span class="o">=</span> <span class="n">xFloats</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">yFloats</span> <span class="o">=</span> <span class="n">yFloats</span>

                    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">xRanked</span><span class="p">,</span> <span class="n">yRanked</span><span class="p">))</span>

                <span class="c1"># and return an empty partition bucket</span>

            <span class="c1"># If there is data, set the bounding box to be the max and min in the data</span>
            <span class="n">xmin</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="n">xmax</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">ymin</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="n">ymax</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

            <span class="c1"># self.borders stores x and y min and max of overall bounding box in &#39;nodes&#39; and the number of points in the bounding box in &#39;npts&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">borders</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">borders</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">borders</span><span class="p">[</span><span class="s1">&#39;npts&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># set parameters for partitioning algorithm</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">setParameters</span><span class="p">(</span><span class="n">partitionParams</span><span class="o">=</span><span class="n">partitionParams</span><span class="p">)</span>

            <span class="c1"># If there is data, use the chosen meshing scheme to build the partitions.</span>
            <span class="k">if</span> <span class="n">meshingScheme</span> <span class="o">==</span> <span class="s1">&#39;DV&#39;</span><span class="p">:</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">partitionBucket</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_partition_DV</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                                                                <span class="n">borders</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">borders</span><span class="p">,</span>
                                                                <span class="n">r</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">numParts</span><span class="p">,</span>
                                                                <span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span>
                                                                <span class="n">c</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">,</span>
                                                                <span class="n">nmin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nmin</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">meshingScheme</span> <span class="o">==</span> <span class="s1">&#39;clustering&#39;</span><span class="p">:</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">partitionBucket</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_partition_clustering</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                                                                        <span class="n">clusterAlg</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">clusterAlg</span><span class="p">,</span>
                                                                        <span class="n">num_clusters</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">numClusters</span><span class="p">,</span>
                                                                        <span class="n">weights</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">,</span>
                                                                        <span class="n">boxOption</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">boxOption</span><span class="p">,</span>
                                                                        <span class="n">boxSize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">boxSize</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>  <span class="c1"># meshingScheme == None</span>
                <span class="c1"># Note that right now, this will just do the dumb thing for every other input</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">partitionBucket</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">borders</span><span class="p">]</span>
                <span class="c1">#  set the partitions to just be the bounding box</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">partitionBucket</span> <span class="o">=</span> <span class="p">[]</span>

<div class="viewcode-block" id="Partitions.convertOrdToFloat"><a class="viewcode-back" href="../../../misc.html#teaspoon.SP.adaptivePart.Partitions.convertOrdToFloat">[docs]</a>    <span class="k">def</span> <span class="nf">convertOrdToFloat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">partitionEntry</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Converts to nodes of a partition entry from ordinal back to floats.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            partitionEntry (dict):</span>
<span class="sd">                The partition that you want to convert.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Partition entry with converted nodes. Also sets dictionary element to the converted version.</span>

<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">bdyList</span> <span class="o">=</span> <span class="n">partitionEntry</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># Need to subtract one to deal with counting from</span>
        <span class="c1"># 0 vs counting from 1 problems</span>
        <span class="n">xLow</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">bdyList</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">xHigh</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">bdyList</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">yLow</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">bdyList</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">yHigh</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">bdyList</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;xFloats&#39;</span><span class="p">):</span>
            <span class="n">xLowFloat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xFloats</span><span class="p">[</span><span class="n">xLow</span><span class="p">]</span>
            <span class="n">xHighFloat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xFloats</span><span class="p">[</span><span class="n">xHigh</span><span class="p">]</span>
            <span class="n">yLowFloat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">yFloats</span><span class="p">[</span><span class="n">yLow</span><span class="p">]</span>
            <span class="n">yHighFloat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">yFloats</span><span class="p">[</span><span class="n">yHigh</span><span class="p">]</span>
            <span class="n">convertedBdyList</span> <span class="o">=</span> <span class="p">[</span><span class="n">xLowFloat</span><span class="p">,</span> <span class="n">xHighFloat</span><span class="p">,</span> <span class="n">yLowFloat</span><span class="p">,</span> <span class="n">yHighFloat</span><span class="p">]</span>
            <span class="n">partitionEntry</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convertedBdyList</span>
            <span class="k">return</span> <span class="n">partitionEntry</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;You&#39;re trying to convert your ordinal data&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;back to floats, but you must have had ordinal&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;to begin with so I can&#39;t.  Exiting...&quot;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">partitionBucket</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;xFloats&#39;</span><span class="p">):</span>  <span class="c1"># if the data wasn&#39;t ordinal</span>
            <span class="n">entry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">partitionBucket</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">entry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convertOrdToFloat</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">entry</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">partitionBucket</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

<div class="viewcode-block" id="Partitions.getOrdinal"><a class="viewcode-back" href="../../../misc.html#teaspoon.SP.adaptivePart.Partitions.getOrdinal">[docs]</a>    <span class="k">def</span> <span class="nf">getOrdinal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Overrides the builtin magic method in the case where you had non-ordinal data but still want the ordinal stuff back.</span>
<span class="sd">        If the data wasn&#39;t ordinal, this has the exact same effect as self[key].</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># overrides the builtin magic method in the case where</span>
        <span class="c1"># you had non-ordinal data but still want the ordinal</span>
        <span class="c1"># stuff back.</span>
        <span class="c1"># If the data wasn&#39;t ordinal, this has the exact same</span>
        <span class="c1"># effect as self[key]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">partitionBucket</span><span class="p">[</span><span class="n">key</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># iterates over the converted entries in the</span>
        <span class="c1"># parameter bucket</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;xFloats&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">convertOrdToFloat</span><span class="p">,</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">partitionBucket</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">partitionBucket</span><span class="p">)</span>

<div class="viewcode-block" id="Partitions.iterOrdinal"><a class="viewcode-back" href="../../../misc.html#teaspoon.SP.adaptivePart.Partitions.iterOrdinal">[docs]</a>    <span class="k">def</span> <span class="nf">iterOrdinal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Functions just like iter magic method without converting each entry back to its float</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># functions just like iter magic method without</span>
        <span class="c1"># converting each entry back to its float</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">partitionBucket</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;!</span>
<span class="sd">        @brief Nicely prints all currently set values in the bucket.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="nb">vars</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="n">output</span> <span class="o">+=</span> <span class="s1">&#39;Variables in partition bucket</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">output</span> <span class="o">+=</span> <span class="s1">&#39;---</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">attrs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">output</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; : &#39;</span>
            <span class="n">output</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="n">key</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="n">output</span> <span class="o">+=</span> <span class="s1">&#39;---</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="k">return</span> <span class="n">output</span>

<div class="viewcode-block" id="Partitions.plot"><a class="viewcode-back" href="../../../misc.html#teaspoon.SP.adaptivePart.Partitions.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Plot the partitions. Can plot in ordinal or float, whichever is in the partition bucket when it&#39;s called.</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># plot the partitions</span>
        <span class="n">fig1</span><span class="p">,</span> <span class="n">ax1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">binNode</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="c1"># print(binNode)</span>
            <span class="c1"># get the bottom left corner</span>
            <span class="n">corner</span> <span class="o">=</span> <span class="p">(</span><span class="n">binNode</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">binNode</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span>

            <span class="c1"># get the width and height</span>
            <span class="n">width</span> <span class="o">=</span> <span class="n">binNode</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">binNode</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">height</span> <span class="o">=</span> <span class="n">binNode</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">binNode</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>

            <span class="c1"># add the corresponding rectangle</span>
            <span class="n">ax1</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">patches</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">(</span><span class="n">corner</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>

        <span class="c1"># Doesn&#39;t show unless we do this</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span></div>

    <span class="c1"># helper function for error checking. Used to make sure input is in</span>
    <span class="c1"># ordinarl coordinates. It checks that when the two data columns are sorted</span>
    <span class="c1"># they are each equal to an ordered vector with the same number of rows.</span>
<div class="viewcode-block" id="Partitions.isOrdinal"><a class="viewcode-back" href="../../../misc.html#teaspoon.SP.adaptivePart.Partitions.isOrdinal">[docs]</a>    <span class="k">def</span> <span class="nf">isOrdinal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dd</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Helper function for error checking. Used to make sure input is in ordinal coordinates.</span>
<span class="sd">        It checks that when the two data columns are sorted they are each equal to an ordered vector with the same number of rows.</span>

<span class="sd">        :param dd:</span>
<span class="sd">            Data in a manyx2 numpy array</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                               <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="n">dd</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span>
                                                    <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="n">dd</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">))))</span></div>

    <span class="c1"># data: is a manyx2 numpy array that contains all the original data</span>
    <span class="c1"># borders: a dictionary that contains &#39;nodes&#39; with a numpyu array of Xmin, Xmax, Ymin, Ymax,</span>
    <span class="c1"># and &#39;npts&#39; which contains the number of points in the bin</span>
    <span class="c1"># r: is the number of partitions</span>
    <span class="c1"># alpha: the significance level to test for independence</span>

<div class="viewcode-block" id="Partitions.return_partition_DV"><a class="viewcode-back" href="../../../misc.html#teaspoon.SP.adaptivePart.Partitions.return_partition_DV">[docs]</a>    <span class="k">def</span> <span class="nf">return_partition_DV</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">borders</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">nmin</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Recursive method that partitions the data based on the DV method.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            data (np.array):</span>
<span class="sd">                A manyx2 numpy array that contains all the data in ordinal format.</span>

<span class="sd">            borders (dict):</span>
<span class="sd">                A dictionary that contains &#39;nodes&#39; with a numpy array of Xmin, Xmax, Ymin, Ymax.</span>

<span class="sd">            r (int):</span>
<span class="sd">                The number of partitions to split in each direction</span>
<span class="sd">                (i.e. r=2 means each partition is recursively split into a</span>
<span class="sd">                2 by 2 grid of partitions)</span>

<span class="sd">            alpha (float):</span>
<span class="sd">                The required significance level for independence to stop partitioning</span>

<span class="sd">            c (int):</span>
<span class="sd">                Parameter for an exit criteria. Partitioning stops if min(width of</span>
<span class="sd">                partition, height of partition) &lt; max(width of bounding box, height</span>
<span class="sd">                of bounding box)/c.</span>

<span class="sd">            nmin (int):</span>
<span class="sd">                Minimum average number of points in each partition to keep recursion going.</span>
<span class="sd">                The default is 5 because chisquare test breaks down with less than 5 points</span>
<span class="sd">                per partition, thus we recommend choosing nmin &gt;= 5.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of dictionaries. Each dictionary corresponds to a partition and</span>
<span class="sd">            contains &#39;nodes&#39;, a numpy array of Xmin, Xmax, Ymin, Ymax of the partition,</span>
<span class="sd">            and &#39;npts&#39;, the number of points in the partition.</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># extract the bin boundaries</span>
        <span class="n">Xmin</span> <span class="o">=</span> <span class="n">borders</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">Xmax</span> <span class="o">=</span> <span class="n">borders</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">Ymin</span> <span class="o">=</span> <span class="n">borders</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">Ymax</span> <span class="o">=</span> <span class="n">borders</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span>

        <span class="c1"># find the number of bins</span>
    <span class="c1">#    numBins = r ** 2</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">Xmin</span><span class="p">)</span>
                       <span class="o">&amp;</span> <span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">Xmax</span><span class="p">)</span>
                       <span class="o">&amp;</span> <span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">Ymin</span><span class="p">)</span>
                       <span class="o">&amp;</span> <span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">Ymax</span><span class="p">))</span>

        <span class="n">partitions</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Exit Criteria:</span>
        <span class="c1"># if either height or width is less than the max size, return</span>
        <span class="n">width</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xFloats</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">Xmax</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">xFloats</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">Xmin</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
        <span class="n">height</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">yFloats</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">Ymax</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">yFloats</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">Ymin</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">c</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">c</span><span class="p">)):</span>
            <span class="c1"># print(&#39;Box getting too small, min(width,height)&lt;&#39;, c)</span>
            <span class="c1"># reject futher partitions, and return original bin</span>
            <span class="n">partitions</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;nodes&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Xmin</span><span class="p">,</span> <span class="n">Xmax</span><span class="p">,</span> <span class="n">Ymin</span><span class="p">,</span> <span class="n">Ymax</span><span class="p">]),</span>
                                  <span class="s1">&#39;npts&#39;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">])})</span>
            <span class="k">return</span> <span class="n">partitions</span>

        <span class="c1"># extract the points in the bin</span>
        <span class="n">Xsub</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">Ysub</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

    <span class="c1">#    print(Xsub.shape, &#39;\t&#39;, Ysub.shape)</span>

        <span class="c1"># find the indices of the points in the x- and y-patches</span>
        <span class="n">idx_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">Xmin</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">Xmax</span><span class="p">))</span>
        <span class="n">idx_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">Ymin</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">Ymax</span><span class="p">))</span>

        <span class="c1"># get the subpartitions</span>
        <span class="n">ai</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span>
            <span class="n">data</span><span class="p">[</span><span class="n">idx_x</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="o">/</span><span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span><span class="p">))</span>
        <span class="n">bj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span>
            <span class="n">data</span><span class="p">[</span><span class="n">idx_y</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="o">/</span><span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span><span class="p">))</span>

        <span class="c1"># get the bin edges</span>
        <span class="n">edges1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="n">Xmin</span><span class="p">],</span> <span class="n">ai</span><span class="p">,</span> <span class="p">[</span><span class="n">Xmax</span><span class="p">]))</span>
        <span class="n">edges2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="n">Ymin</span><span class="p">],</span> <span class="n">bj</span><span class="p">,</span> <span class="p">[</span><span class="n">Ymax</span><span class="p">]))</span>

        <span class="c1"># first exit criteria: we cannot split inot unique boundaries any more</span>
        <span class="c1"># preallocate the partition list</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">edges1</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span> <span class="ow">or</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">edges2</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>

            <span class="c1"># reject futher partitions, and return original bin</span>
            <span class="n">partitions</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;nodes&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Xmin</span><span class="p">,</span> <span class="n">Xmax</span><span class="p">,</span> <span class="n">Ymin</span><span class="p">,</span> <span class="n">Ymax</span><span class="p">]),</span>
                                  <span class="s1">&#39;npts&#39;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">])})</span>
            <span class="k">return</span> <span class="n">partitions</span>

        <span class="c1"># figure out the shift in the edges so that boundaries do not overlap</span>
        <span class="n">xShift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">r</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">r</span><span class="p">))</span>
        <span class="n">yShift</span> <span class="o">=</span> <span class="n">xShift</span>
        <span class="n">xShift</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]),</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">r</span><span class="p">,</span> <span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">yShift</span> <span class="o">=</span> <span class="n">xShift</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># find the boundaries for each bin</span>
        <span class="c1"># duplicate inner nodes for x mesh</span>
        <span class="n">dupMidNodesX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">((</span><span class="n">edges1</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                                           <span class="mi">0</span><span class="p">,</span> <span class="n">edges1</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">edges1</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># duplicate inner nodes for y mesh</span>
        <span class="n">dupMidNodesY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">((</span><span class="n">edges2</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                                           <span class="mi">0</span><span class="p">,</span> <span class="n">edges2</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">edges2</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># reshape</span>
        <span class="n">dupMidNodesY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">dupMidNodesY</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c1"># now find the nodes for each bin</span>
        <span class="n">xBinBound</span> <span class="o">=</span> <span class="n">dupMidNodesX</span> <span class="o">+</span> <span class="n">xShift</span>
        <span class="n">yBinBound</span> <span class="o">=</span> <span class="n">dupMidNodesY</span> <span class="o">+</span> <span class="n">yShift</span>

        <span class="c1"># find the number of points in each bin, and put this info into array</span>
        <span class="n">binned_data</span> <span class="o">=</span> <span class="n">binned_statistic_2d</span><span class="p">(</span><span class="n">Xsub</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">Ysub</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;count&#39;</span><span class="p">,</span>
                                          <span class="n">bins</span><span class="o">=</span><span class="p">[</span><span class="n">edges1</span><span class="p">,</span> <span class="n">edges2</span><span class="p">])</span>
        <span class="c1"># get the counts. Flatten columnwise to match the bin definition in the</span>
        <span class="c1"># loop that creates the dictionaries below</span>
        <span class="n">binCounts</span> <span class="o">=</span> <span class="n">binned_data</span><span class="o">.</span><span class="n">statistic</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>

        <span class="c1"># Exit Criteria:</span>
        <span class="c1"># check if sum of bin counts is less than threshold of nmin per bin</span>
        <span class="c1"># nmin is necessary because chisquare breaks down if you have less than</span>
        <span class="c1"># 5 points in each bin</span>
        <span class="k">if</span> <span class="n">nmin</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">binCounts</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">nmin</span> <span class="o">*</span> <span class="p">(</span><span class="n">r</span><span class="o">**</span><span class="mi">2</span><span class="p">):</span>
                <span class="n">partitions</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;nodes&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">Xmin</span><span class="p">,</span> <span class="n">Xmax</span><span class="p">,</span> <span class="n">Ymin</span><span class="p">,</span> <span class="n">Ymax</span><span class="p">]),</span> <span class="s1">&#39;npts&#39;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">])})</span>
                <span class="k">return</span> <span class="n">partitions</span>

        <span class="c1"># define an empty list to hold the dictionaries of the fresh partitions</span>
        <span class="n">bins</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># create dictionaries for each bin</span>
        <span class="c1"># start with the loop over y</span>
        <span class="c1"># note how the loop counts were obtained above to match the convention</span>
        <span class="c1"># here</span>
        <span class="k">for</span> <span class="n">yInd</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
            <span class="c1"># this is the loop over x</span>
            <span class="k">for</span> <span class="n">xInd</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
                <span class="c1"># get the bin number</span>
                <span class="n">binNo</span> <span class="o">=</span> <span class="n">yInd</span> <span class="o">*</span> <span class="n">r</span> <span class="o">+</span> <span class="n">xInd</span>
                <span class="n">xLow</span><span class="p">,</span> <span class="n">xHigh</span> <span class="o">=</span> <span class="n">xBinBound</span><span class="p">[</span><span class="n">yInd</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">xInd</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>
                <span class="n">yLow</span><span class="p">,</span> <span class="n">yHigh</span> <span class="o">=</span> <span class="n">yBinBound</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">yInd</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">xInd</span><span class="p">]</span>
                <span class="n">bins</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;nodes&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xLow</span><span class="p">,</span> <span class="n">xHigh</span><span class="p">,</span> <span class="n">yLow</span><span class="p">,</span> <span class="n">yHigh</span><span class="p">]),</span>
                             <span class="s1">&#39;npts&#39;</span><span class="p">:</span> <span class="n">binCounts</span><span class="p">[</span><span class="n">binNo</span><span class="p">]})</span>

        <span class="c1"># calculate the chi square statistic</span>
        <span class="n">chi2</span> <span class="o">=</span> <span class="n">chisquare</span><span class="p">(</span><span class="n">binCounts</span><span class="p">)</span>

        <span class="c1"># check for independence and start recursion</span>
        <span class="c1"># if the chi2 test fails, do further partitioning:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">chi2</span><span class="o">.</span><span class="n">pvalue</span> <span class="o">&lt;</span> <span class="n">alpha</span> <span class="ow">and</span> <span class="n">Xmax</span> <span class="o">!=</span> <span class="n">Xmin</span> <span class="ow">and</span> <span class="n">Ymax</span> <span class="o">!=</span> <span class="n">Ymin</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">binInfo</span> <span class="ow">in</span> <span class="n">bins</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">binInfo</span><span class="p">[</span><span class="s1">&#39;npts&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># if the bin is not empty:</span>
                    <span class="c1"># append entries to the tuple</span>
                    <span class="n">partitions</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">return_partition_DV</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                                                               <span class="n">borders</span><span class="o">=</span><span class="n">binInfo</span><span class="p">,</span>
                                                               <span class="n">r</span><span class="o">=</span><span class="n">r</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">))</span>

        <span class="c1"># Second exit criteria:</span>
        <span class="c1"># if the partitions are independent, reject further partitioning and</span>
        <span class="c1"># save the orignal, unpartitioned bin</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">partitions</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;nodes&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Xmin</span><span class="p">,</span> <span class="n">Xmax</span><span class="p">,</span> <span class="n">Ymin</span><span class="p">,</span> <span class="n">Ymax</span><span class="p">]),</span>
                                  <span class="s1">&#39;npts&#39;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">])})</span>

        <span class="k">return</span> <span class="n">partitions</span></div>

<div class="viewcode-block" id="Partitions.return_partition_clustering"><a class="viewcode-back" href="../../../misc.html#teaspoon.SP.adaptivePart.Partitions.return_partition_clustering">[docs]</a>    <span class="k">def</span> <span class="nf">return_partition_clustering</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">clusterAlg</span><span class="o">=</span><span class="n">KMeans</span><span class="p">,</span> <span class="n">num_clusters</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">boxOption</span><span class="o">=</span><span class="s2">&quot;boundPoints&quot;</span><span class="p">,</span> <span class="n">boxSize</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Partitioning method based on clustering algorithms. First cluster the data, then using the cluster centers and labels determine the partitions.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            data (np.array):</span>
<span class="sd">                A manyx2 numpy array that contains all the original data (not ordinals).</span>

<span class="sd">            cluster_algorithm (function):</span>
<span class="sd">                Clustering algorithm you want to use. Only options right now are</span>
<span class="sd">                KMeans and MiniBatchKMeans from scikit learn.</span>

<span class="sd">            num_clusters (int):</span>
<span class="sd">                The number of clusters you want. This is the number of partitions</span>
<span class="sd">                you want to divide your space into.</span>

<span class="sd">            weights (np.array):</span>
<span class="sd">                An array of the same length as data containing weights of points to use weighted clustering</span>

<span class="sd">            boxOption (str):</span>
<span class="sd">                Specifies how to choose the boxes based on cluster centers. Only option right now is</span>
<span class="sd">                &quot;boundPoints&quot; which takes the bounding box of all data points assigned to that cluster center.</span>
<span class="sd">                Additional options may be added in the future.</span>

<span class="sd">            boxSize (int):</span>
<span class="sd">                This input is not used as of now.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of dictionaries. Each dictionary corresponds to a partition and contains &#39;nodes&#39;,</span>
<span class="sd">            a numpy array of Xmin, Xmax, Ymin, Ymax of the partition, and &#39;center&#39;, the center of the</span>
<span class="sd">            cluster for that partition.</span>

<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">if</span> <span class="n">weights</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">sample_weights</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">weights</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">sample_weights</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sample_weights</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Fit using whatever the chosen cluster algorithm is</span>
        <span class="n">kmeans</span> <span class="o">=</span> <span class="n">clusterAlg</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="n">num_clusters</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
            <span class="n">data</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="n">sample_weights</span><span class="p">)</span>

        <span class="c1"># Get the centers of each cluster and the labels for the data points</span>
        <span class="n">centers</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">cluster_centers_</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">labels_</span>

        <span class="n">bins</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Using this optin, take the bounding box of points closest to each cluster center</span>
        <span class="c1"># These will be the partitions</span>
        <span class="k">if</span> <span class="n">boxOption</span> <span class="o">==</span> <span class="s2">&quot;boundPoints&quot;</span><span class="p">:</span>

            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labels</span><span class="p">):</span>
                <span class="n">cluster</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">labels</span> <span class="o">==</span> <span class="n">l</span><span class="p">]</span>

                <span class="n">xmin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">cluster</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
                <span class="n">xmax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">cluster</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
                <span class="n">ymin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">cluster</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
                <span class="n">ymax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">cluster</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>

                <span class="c1"># issues if bounding box touches x-axis so print a warning if it does</span>
                <span class="c1"># if ymin == 0:</span>
                <span class="c1">#     print(&quot;Uh oh can&#39;t have points with zero lifetime!&quot;)</span>

                <span class="n">bins</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span>
                    <span class="mi">0</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;nodes&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">],</span> <span class="s1">&#39;center&#39;</span><span class="p">:</span> <span class="n">centers</span><span class="p">[</span><span class="n">l</span><span class="p">]})</span>

        <span class="c1"># # Using this option, put the equal size box centered at each cluster center</span>
        <span class="c1"># # These are then the partitions and we ignore anything outside them</span>
        <span class="c1"># elif boxOption == &quot;equalSize&quot;:</span>
        <span class="c1">#     print(&quot;STOP: the &#39;equalSize&#39; option has not been debugged. It may be available later.&quot;)</span>
        <span class="c1">#     print(&quot;If you used this option, I&#39;m just giving you back the bounding box.&quot;)</span>
        <span class="c1">#</span>
        <span class="c1">#     bins.insert(0, {&#39;nodes&#39;:[ min(data[:,0]), max(data[:,0]), min(data[:,1]), max(data[:,1]) ]})</span>
        <span class="c1">#</span>
        <span class="c1">#     ######################################################################</span>
        <span class="c1">#     ### DON&#39;T DELETE</span>
        <span class="c1">#     ### This is a starting point but commented out because it doesn&#39;t work</span>
        <span class="c1">#     ### properly. There is no error checking so boxes could cross x axis</span>
        <span class="c1">#     ### which we can&#39;t have so needs more before it is usable</span>
        <span class="c1">#     ######################################################################</span>
        <span class="c1">#     # if isinstance(boxSize, int):</span>
        <span class="c1">#     #     boxSize = list([boxSize,boxSize])</span>
        <span class="c1">#     #</span>
        <span class="c1">#     # for l in np.unique(labels):</span>
        <span class="c1">#     #     center = centers[l]</span>
        <span class="c1">#     #</span>
        <span class="c1">#     #     xmin = center[0] - boxSize[0]/2</span>
        <span class="c1">#     #     xmax = center[0] + boxSize[0]/2</span>
        <span class="c1">#     #     ymin = center[1] - boxSize[1]/2</span>
        <span class="c1">#     #     ymax = center[1] + boxSize[1]/2</span>
        <span class="c1">#     #</span>
        <span class="c1">#     #     bins.insert(0,{&#39;nodes&#39;: [xmin,xmax,ymin,ymax], &#39;center&#39;: centers[l]})</span>
        <span class="c1">#     ######################################################################</span>

        <span class="k">return</span> <span class="n">bins</span></div>

<div class="viewcode-block" id="Partitions.setParameters"><a class="viewcode-back" href="../../../misc.html#teaspoon.SP.adaptivePart.Partitions.setParameters">[docs]</a>    <span class="k">def</span> <span class="nf">setParameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">partitionParams</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Helper function to set the parameters depending on the meshing scheme.</span>
<span class="sd">        If any are not specified, it is set to a default value.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            partitionParams:</span>
<span class="sd">                Dictionary containing parameters needed for the partitioning algorithm.</span>

<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshingScheme</span> <span class="o">==</span> <span class="s1">&#39;DV&#39;</span><span class="p">:</span>

            <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">borders</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">]</span>

            <span class="c1"># c det</span>
            <span class="k">if</span> <span class="s1">&#39;c&#39;</span> <span class="ow">in</span> <span class="n">partitionParams</span><span class="p">:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">partitionParams</span><span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">c</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># convert c from integer to the corresponding width/height</span>
                    <span class="n">width</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xFloats</span><span class="p">[</span><span class="n">xmax</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">xFloats</span><span class="p">[</span><span class="n">xmin</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">c</span>
                    <span class="n">height</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">yFloats</span><span class="p">[</span><span class="n">ymax</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">yFloats</span><span class="p">[</span><span class="n">ymin</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">c</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># c=0 means we don&#39;t use this paramter for an exit criteria</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="mi">10</span>
                <span class="c1"># convert c from integer to the corresponding width/height</span>
                <span class="n">width</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xFloats</span><span class="p">[</span><span class="n">xmax</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">xFloats</span><span class="p">[</span><span class="n">xmin</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">c</span>
                <span class="n">height</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">yFloats</span><span class="p">[</span><span class="n">ymax</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">yFloats</span><span class="p">[</span><span class="n">ymin</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">c</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span>

            <span class="k">if</span> <span class="s1">&#39;alpha&#39;</span> <span class="ow">in</span> <span class="n">partitionParams</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">partitionParams</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.05</span>

            <span class="k">if</span> <span class="s1">&#39;nmin&#39;</span> <span class="ow">in</span> <span class="n">partitionParams</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nmin</span> <span class="o">=</span> <span class="n">partitionParams</span><span class="p">[</span><span class="s1">&#39;nmin&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nmin</span> <span class="o">=</span> <span class="mi">5</span>

            <span class="k">if</span> <span class="s1">&#39;numParts&#39;</span> <span class="ow">in</span> <span class="n">partitionParams</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">numParts</span> <span class="o">=</span> <span class="n">partitionParams</span><span class="p">[</span><span class="s1">&#39;numParts&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">numParts</span> <span class="o">=</span> <span class="mi">2</span>

            <span class="c1"># if self.convertToOrd == False:</span>
            <span class="c1">#     self.convertToOrd = True</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshingScheme</span> <span class="o">==</span> <span class="s1">&#39;clustering&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;clusterAlg&#39;</span> <span class="ow">in</span> <span class="n">partitionParams</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">clusterAlg</span> <span class="o">=</span> <span class="n">partitionParams</span><span class="p">[</span><span class="s1">&#39;clusterAlg&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">clusterAlg</span> <span class="o">=</span> <span class="n">KMeans</span>

            <span class="k">if</span> <span class="s1">&#39;numClusters&#39;</span> <span class="ow">in</span> <span class="n">partitionParams</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">numClusters</span> <span class="o">=</span> <span class="n">partitionParams</span><span class="p">[</span><span class="s1">&#39;numClusters&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">numClusters</span> <span class="o">=</span> <span class="mi">5</span>

            <span class="k">if</span> <span class="s1">&#39;weights&#39;</span> <span class="ow">in</span> <span class="n">partitionParams</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">partitionParams</span><span class="p">[</span><span class="s1">&#39;weights&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">if</span> <span class="s1">&#39;pad&#39;</span> <span class="ow">in</span> <span class="n">partitionParams</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pad</span> <span class="o">=</span> <span class="n">partitionParams</span><span class="p">[</span><span class="s1">&#39;pad&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pad</span> <span class="o">=</span> <span class="mf">0.1</span>

            <span class="k">if</span> <span class="s1">&#39;boxOption&#39;</span> <span class="ow">in</span> <span class="n">partitionParams</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">boxOption</span> <span class="o">=</span> <span class="n">partitionParams</span><span class="p">[</span><span class="s1">&#39;boxOption&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">boxOption</span> <span class="o">=</span> <span class="s2">&quot;boundPoints&quot;</span>

            <span class="k">if</span> <span class="s1">&#39;boxSize&#39;</span> <span class="ow">in</span> <span class="n">partitionParams</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">boxSize</span> <span class="o">=</span> <span class="n">partitionParams</span><span class="p">[</span><span class="s1">&#39;boxSize&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">boxSize</span> <span class="o">=</span> <span class="mi">2</span>

            <span class="c1"># if self.convertToOrd == True:</span>
            <span class="c1">#     self.convertToOrd = False</span>

        <span class="k">if</span> <span class="s1">&#39;split&#39;</span> <span class="ow">in</span> <span class="n">partitionParams</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">split</span> <span class="o">=</span> <span class="n">partitionParams</span><span class="p">[</span><span class="s1">&#39;split&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">split</span> <span class="o">=</span> <span class="kc">False</span></div></div>

<span class="c1"># --------------------------------------------------</span>


<span class="c1"># this part tests the adaptive meshing algorithm</span>
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="c1"># generate a bivariate Gaussian</span>

    <span class="c1"># fix the seed For reproducibility</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">48824</span><span class="p">)</span>

    <span class="c1"># create a bivariate Gaussian</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>  <span class="c1"># the means</span>
    <span class="n">cov</span> <span class="o">=</span> <span class="mf">0.7</span>  <span class="c1"># covariance</span>
    <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="n">cov</span><span class="p">],</span> <span class="p">[</span><span class="n">cov</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>  <span class="c1"># covariance matrix</span>

    <span class="c1"># create the multivariate random variable</span>
    <span class="n">nsamples</span> <span class="o">=</span> <span class="mi">100</span>  <span class="c1"># number of random samples</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">nsamples</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

    <span class="c1"># # perform ordinal sampling (ranking) transformation</span>
    <span class="c1"># xRanked = rankdata(x, method=&#39;ordinal&#39;)</span>
    <span class="c1"># yRanked = rankdata(y, method=&#39;ordinal&#39;)</span>

    <span class="c1"># obtain the adaptive mesh</span>
    <span class="n">numParts</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="c1"># get the adaptive partition of the data</span>
    <span class="n">partitionList</span> <span class="o">=</span> <span class="n">Partitions</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)),</span>
                               <span class="n">meshingScheme</span><span class="o">=</span><span class="s2">&quot;DV&quot;</span><span class="p">,</span>
                               <span class="n">partitionParams</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;numParts&#39;</span><span class="p">:</span> <span class="n">numParts</span><span class="p">},</span>
                               <span class="n">convertToOrd</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># plot the partitions</span>
    <span class="n">partitionList</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>

    <span class="c1"># overlay the data</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;r*&#39;</span><span class="p">)</span>

    <span class="c1"># add formatting</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
    <span class="c1"># show the figure</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, Munch.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
    <!-- Theme Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-XXXXXXX-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-XXXXXXX-1', {
          'anonymize_ip': false,
      });
    </script> 

</body>
</html>